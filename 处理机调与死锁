处理机调度的层次
高级调度->中级调度->进程调度

  高级调度（作业调度、长程调度）：把外存上处于后备队列中的那些作业调入内存
  批处理系统中，使用作业调度，但是在分时系统和实时系统中不需要作业调度
    1）作业、作业布、作业流
    2）作业控制块JCB
    3）作业调度：决定接纳多少个作业、决定接纳哪些作业
    
  低级调度：进程调度、短程调度
  在多道批处理、分时系统、实时系统都需要进程调度
    1）低级调度的功能：
      保存处理机的现场信息
      按某种算法选取进程
      把处理器分配给进程
    2）进程调度的三个基本机制：
      排队器
      分派器
      上下文切换机
    3）进程调度方式
      非抢占方式：适合批处理系统环境
      抢占方式：优先权原则、短作业（进程）优先原则、时间片原则（此原则适合分时系统、大多数实时系统和较高要求的批处理系统）
  
  中级调度：为了提高内存利用率和系统吞吐量
    使哪些暂时不能运行的进程不再占有宝贵的内存资源，而将它们调至外存上去等待，把此时的进程状态称为就绪驻外村状态或挂起状态
    当这些进程重又具备运行条件且内存又少有空闲时，由中级调度来决定把外存上的那些又具备运行条件的就绪进程重新调入内存，并修改其状态为就绪撞他，挂在据就绪队列上等待进程调度
    
    
调度队列模型和调度准备
  调度队列模型
  1）仅有进程调度的调度队列模型：树、栈、无序链表
    a）任务在给定的时间片内已经完成，该进程便在释放处理机后进入完成状态
    b）任务在本次分得得时间片内尚未完成，OS便将该任务再放入就绪队列的末尾
    c）在执行期间，进程因为某事件而被阻塞后，被OS放入阻塞队列的末尾
  2）具有高级和低级调度的调度队列模型
    a）就绪队列的形式
    b）设置多个阻塞队列
  3）同时具有三级调度的调度队列模型
  
  选择调度方式和调度算法的若干准则
    1）面向用户的准则：
      a）周转时间短
        周转时间，指从作业被提交给系统开始，到作业完成为止的这段时间间隔成为作业周转时间。
          作业在外存后备队列上等待作业调度的时间
          进程在就绪队列上等待进程调度的时间
          进程在CPU上执行的时间
          进程等待I/O操作完成的时间
      b）响应时间快
        从键盘输入的请求信息传送到处理机的时间，
        处理机对请求信息进行处理的时间，
        以及将所形成的响应信息会送到终端显示器的时间
      c）截止时间的保证：某任务必须开始执行的最迟时间
      d）优先权准则
    2）面向系统的准则
      a）系统吞吐量
      b）处理机利用率好
      c）各类资源的平衡利用
      
调度算法：根据系统的资源分配策略所规定的资源分配算法
  先来先服务和短作业（进程）优化调度算法 FCFS
    1）先来先服务调度算法FCFS：作业调度或进程调度
      适用于长作业而不利于短作业
      适用于CPU繁忙型的作业，不利于I/O繁忙型的作业
    2）短作业（进程）优先调度算法 SJ(P)F：作业调度和进程调度
      该算法对长作业不利
      该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理
      由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先处理调度
  
  高优先权优先调度算法：
    1）优先权调度算法的类型 FPF做高优先权有效调度算法
      a）非抢占式优先权算法：批处理系统
      b）抢占式优先权调度算法：三种系统
    2）优先权的类型
      a）静态优先权
        进程类型：通常系统进程的优先权高于一般用户进程的优先权
        进程对资源的需求：如进程的估计执行时间及内存需要量的多少，对这些要求少的进程应赋予较高的优先权
        用户要求：这是由用户进程的紧迫程度及用户所付费用的所烧来确定优先权的
      b）动态优先权
    3）高响应必优先调度算法
  
  基于时间片的轮转调度算法：分时系统
    1）时间片轮转法
      基本原理：系统能在给定的时间内响应所有用户的请求
      时间片大小的确定：略大于一次交互的时间
    2）多级反馈队列调度算法
      应设置多个就绪队列，并为各个队列赋予不同的优先级
      当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度
      仅当第一队列空闲时，调度程序才调度第二队列中的进程运行
      
      
实时调度
  实现实时调度的基本条件：
    1）提供必要的信息：就绪时间、开始截止时间和完成截至时间、处理时间、资源要求、优先级
    2）系统处理能力强
    3）采用抢占式调度机制
    4）具有快速切换机制
  实时调度算法的分类：
    非抢占式调度算法：非抢占式轮转调度算法、非抢占式优先调度算法
    抢占式调度算法：基于时钟中断优先调度算法、立即抢占的优先权调度算法
  常用的几种实时调度算法：
    1）最早截止时间优先即EDF算法
    2）最低松弛度优先即LLF算法
    
产生死锁的原因和必要条件
死锁：多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态是，若无外力作用，他们都将无法再向前推进。
  产生死锁的原因：
    1）竞争资源
    2）进程推进顺序不当
  产生死锁的必要条件
    1）互斥条件
    2）请求和保持条件
    3）不剥夺条件
    4）环路等待条件
  处理死锁的基本方法
    1）预防死锁
    2）避免死锁
    3）检测死锁
    4）解除死锁
  
预防死锁的方法：预防死锁和避免死锁
  预防死锁：
    1）摒弃“请求和保持”条件
    2）摒弃“不剥夺”条件
    3）摒弃“环路等待”条件
  系统安全状态：
    1）安全状态：是指系统能按某种进程顺序来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成
    2）由安全状态向不安全状态的转换
  利用银行家算法避免死锁
    1）银行家算法中的数据结构
      可利用资源向量Available
      最大需求矩阵Max
      分配矩阵Allocation
      需求矩阵Need
    2）银行家算法
    3）安全性算法
  
死锁的检测与解除
  死锁的检测
  1）保存有关资源的请求和分配信息
  2）提供一种算法，以利用这些信息来检测系统是否已进入死锁状态
    资源分配图Resorce Allocation Grpah
    死锁定理：当且仅当S状态的资源分配图是不可完全简化的
    死锁检测中的数据结构
  死锁的解除
  1）剥夺资源
  2）撤销进程
    
    
